#+title: Problems

* Лаба #1

Выполнить распечатку GIMPLE/IR из gcc компилятора. Например, это можно сделать
из ./gcc-4.9.0/gcc/tree-ssa-dce.c. (4.9.0 или другая версия). Как вариант, можно
сделать распечатку из плагина для GCC. На ваше усмотрение.


Эта распечатка должна в себя включать следующее:

- базовые блоки
- блоки-предшественники
- блоки-последователи
- содержимое базовых блоков (GIMPLE инструкции):
  - арифметические операции
  - Ф-функции
  - инструкции ветвления
  - выражения доступа в память (ArrayRef и др)


P.S. tree-ssa-dce.c - оптимизирующий проход DCE (Dead Code Elimination) на базе
SSA

[[./gcc-plugins.pdf]]

попробуйте сделать просто пустой Plugin, где будет выводиться "Привет, Мир !"
для начала

важно: не использовать встроенные в GCC функции типа print_gimple_stmt - только
стандартный printf
* Лаба #2

попробуйте посмотреть в исходном коде LLVM пример, который называется
kaleidoscope

Написать простейший "компилятор" на базе LLVM, который ничего на вход не берёт.
Генерирует LLVM код для функции:

#+begin_src c
int main() {
    return 353 + 48;
}
#+end_src

Простейший компилятор должен печатать LLVM-код на консоль
* Лаба #3
Написать простейший компилятор на базе LLVM для простейшего языка, который
содержит следующее:

- 2-3 арифметические операции с присвоением результата переменной
- 2-3 структуры управления (например, цикл for, инструкция if)
- целочисленный тип
- передача целочисленного результата через return в функции main (в программе
  только одна функция)

Простейший компилятор должен печатать LLVM-код на консоль.
* Лаба #4
Построение SSA

Реализовать простейший компилятор (на любом языке):

   - простой фронтенд (можно взять из предыдущей лабы)
   - реализовать CFG
   - на базе CFG реализовать простейший IR
   - построить SSA форму над данным представлением


Предусмотреть также вывод графа через GraphVis
